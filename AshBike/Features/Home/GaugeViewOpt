//
//  GaugeView.swift
//  AshBike
//
//  Created by Siamak Ashrafi on 5/23/25.
//
import SwiftUI

// MARK: - FIX: Add this line
private let headingDirections = ["N", "NNE", "NE", "ENE", "E", "ESE", "SE", "SSE", "S", "SSW", "SW", "WSW", "W", "WNW", "NW", "NNW"]

struct GaugeView: View, Equatable {
    var speed: Double
    var heading: Double
    var maxSpeed: Double = 60
    var onMapButtonTapped: () -> Void // Action to show the map

    static func == (lhs: GaugeView, rhs: GaugeView) -> Bool {
        lhs.speed == rhs.speed &&
        lhs.heading == rhs.heading &&
        lhs.maxSpeed == rhs.maxSpeed
    }

    // Background circle view builder
    @ViewBuilder
    private var backgroundCircle: some View {
        Circle()
            .foregroundStyle(.thinMaterial)
            .background(.blue.opacity(0.3))
            .clipShape(Circle())
            .shadow(color: .black.opacity(0.3), radius: 10) // Shadow causes potential clipping
            .allowsHitTesting(false)
            .accessibilityHidden(true)
    }

    var body: some View {
        GeometryReader { geometry in
            // Use the full size provided by GeometryReader for calculations
            let radius = min(geometry.size.width, geometry.size.height) / 2
            let center = CGPoint(x: geometry.size.width / 2, y: geometry.size.height / 2)

            ZStack { // This ZStack fills the GeometryReader
                // Layer 1: Background
                backgroundCircle // Drawn centered in the ZStack

                // Layer 2: Arc (Uses calculated radius)
                LiquidGlassArcView(radius: radius, speed: speed, maxSpeed: maxSpeed)
                    .allowsHitTesting(false)
                    .accessibilityHidden(true)

                // Layer 3: Ticks and Labels (Uses calculated radius & center)
                TicksAndLabelsView(center: center, radius: radius, maxSpeed: maxSpeed)
                    .equatable()
                    .allowsHitTesting(false)
                    .accessibilityHidden(true)

                // Layer 4: Needle (Uses calculated radius)
                NeedleView(radius: radius, speed: speed, maxSpeed: maxSpeed)
                    .equatable()
                    .allowsHitTesting(false)
                    .accessibilityHidden(true)

                // Layer 5: Center Text (Uses calculated radius)
                CenterTextView(radius: radius, speed: speed, heading: heading, maxSpeed: maxSpeed)
                    .equatable()
                    .allowsHitTesting(false)
                    .accessibilityHidden(true)

                // Layer 6: Map Button (Positioned within the ZStack)
                MapButton(action: onMapButtonTapped)
            }
            // Ensure the ZStack fills the space defined by GeometryReader
            .frame(width: geometry.size.width, height: geometry.size.height)
        }
        // Maintain the aspect ratio for the overall GaugeView
        .aspectRatio(1, contentMode: .fit)
        // IMPORTANT: Padding must be applied *externally* in HomeView to prevent clipping
    }
}


// MARK: - Sub-components for GaugeView

private struct LiquidGlassArcView: View, Equatable {
    let radius: CGFloat
    let speed: Double
    let maxSpeed: Double

    // Reuse the gradient to avoid reallocation on each render
    private static let gradient = AngularGradient(
        gradient: Gradient(colors: [.green, .yellow, .orange, .red]),
        center: .center,
        startAngle: .degrees(135),
        endAngle: .degrees(405)
    )

    static func == (lhs: LiquidGlassArcView, rhs: LiquidGlassArcView) -> Bool {
        lhs.radius == rhs.radius && lhs.speed == rhs.speed && lhs.maxSpeed == rhs.maxSpeed
    }

    private var progress: Double { min(speed / maxSpeed, 1.0) }
    private var glassStrokeStyle: StrokeStyle { StrokeStyle(lineWidth: radius * 0.22, lineCap: .round) }
    private var colorStrokeStyle: StrokeStyle { StrokeStyle(lineWidth: radius * 0.18, lineCap: .round) }

    // Extracted colored portion for reuse
    private var coloredPortion: some View {
        GaugeArcShape()
            .trim(from: 0, to: progress)
            .stroke(Self.gradient, style: colorStrokeStyle)
    }

    var body: some View {
        ZStack {
            // 1. Base Frosted Glass Track
            GaugeArcShape()
                .stroke(style: glassStrokeStyle)
                .foregroundStyle(.ultraThinMaterial)
                .shadow(color: .black.opacity(0.3), radius: 8, x: 5, y: 5) // Inner shadow for depth
                .overlay {
                    // Inner shadow effect
                    GaugeArcShape()
                        .stroke(Color.black.opacity(0.4), lineWidth: 1)
                        .blur(radius: 2)
                        .offset(x: 1, y: 1)
                        .mask(GaugeArcShape().stroke(style: glassStrokeStyle))
                    // Top highlight effect
                    GaugeArcShape()
                        .stroke(LinearGradient(colors: [.white.opacity(0.4), .clear], startPoint: .top, endPoint: .bottom), lineWidth: 3)
                        .blur(radius: 2)
                        .mask(GaugeArcShape().stroke(style: glassStrokeStyle))
                }

            // Grouping for drawingGroup optimization
            Group {
                // 4. Soft glow layer
                coloredPortion
                    .blur(radius: 20)
                    .opacity(0.8)
                    .blendMode(.screen)

                // 5. Crisp color layer on top
                coloredPortion
                    .overlay { // Glossy highlight on colored part
                        GaugeArcShape()
                            .stroke(LinearGradient(colors: [.white.opacity(0.7), .clear], startPoint: .top, endPoint: .bottom), lineWidth: 2)
                            .blur(radius: 1)
                            .mask(coloredPortion)
                    }
            }
            .drawingGroup() // Optimizes rendering of complex static content
        }
    }
}


private struct TicksAndLabelsView: View, Equatable {
    let center: CGPoint // Passed from GeometryReader
    let radius: CGFloat // Passed from GeometryReader
    let maxSpeed: Double
    private let tickCount = 7

    static func == (lhs: TicksAndLabelsView, rhs: TicksAndLabelsView) -> Bool {
        lhs.center == rhs.center && lhs.radius == rhs.radius && lhs.maxSpeed == rhs.maxSpeed
    }

    // Helper struct for pre-computed tick data
    private struct TickData: Identifiable {
        let id: Int
        let value: Double
        let angle: Angle
    }

    // Pre-compute tick data to avoid calculations inside the loop
    private var tickData: [TickData] {
        (0..<tickCount).map { i in
            let value = Double(i) * (maxSpeed / Double(tickCount - 1))
            let angle = angleForValue(value)
            return TickData(id: i, value: value, angle: angle)
        }
    }

    // Use Canvas for optimized drawing
    var body: some View {
        Canvas { context, size in
            // Pass the correct center and radius from the parent GeometryReader
            drawTicksAndLabels(context: &context, size: size, center: center, radius: radius)
        }
    }

    // Drawing logic extracted into a separate function for compiler performance
    private func drawTicksAndLabels(context: inout GraphicsContext, size: CGSize, center: CGPoint, radius: CGFloat) {
        // Resolve colors and font once outside the loop
        let tickColor = Color.black.opacity(0.7)
        let labelFont = Font.system(size: radius * 0.1, weight: .bold) // Use passed radius
        let labelColor = Color.black.opacity(0.8)

        for data in tickData {
            // Convert angle to CGFloat once per iteration
            let angle = CGFloat(data.angle.radians)

            // --- Draw Ticks --- (Uses passed center and radius)
            let tickOuter = CGPoint(
                x: center.x + (radius * 0.9) * cos(angle),
                y: center.y + (radius * 0.9) * sin(angle)
            )
            let tickInner = CGPoint(
                x: center.x + (radius * 0.9 - 10) * cos(angle),
                y: center.y + (radius * 0.9 - 10) * sin(angle)
            )

            var path = Path()
            path.move(to: tickOuter)
            path.addLine(to: tickInner)
            context.stroke(path, with: .color(tickColor), lineWidth: 2)

            // --- Draw Labels --- (Uses passed center and radius)
            let labelPoint = CGPoint(
                x: center.x + (radius * 0.78) * cos(angle),
                y: center.y + (radius * 0.78) * sin(angle)
            )

            // Correct way to draw styled Text in Canvas
            context.draw(
                Text(String(format: "%.0f", data.value))
                    .font(labelFont)
                    .foregroundStyle(labelColor),
                at: labelPoint,
                anchor: .center
            )
        }
    }

    // Calculates the angle for a given speed value on the gauge arc
    private func angleForValue(_ value: Double) -> Angle {
        .degrees(135) + .degrees(270 * (value / maxSpeed))
    }
}


// Helper function to format heading direction
private func headingString(from direction: Double) -> String {
    let index = Int((direction + 11.25) / 22.5) & 15 // Efficient modulo 16
    return String(format: "%.0fÂ° %@", direction, headingDirections[index])
}


private struct CenterTextView: View, Equatable {
    let radius: CGFloat
    let speed: Double
    let heading: Double
    let maxSpeed: Double

    static func == (lhs: CenterTextView, rhs: CenterTextView) -> Bool {
        lhs.radius == rhs.radius && lhs.speed == rhs.speed && lhs.heading == rhs.heading && lhs.maxSpeed == rhs.maxSpeed
    }

    // Calculate speed color based on the same gradient as the arc
    private var speedColor: Color {
        let colors: [Color] = [.green, .yellow, .orange, .red]
        return Color.colorForSpeed(speed: speed, maxSpeed: maxSpeed, colors: colors)
    }

    var body: some View {
        VStack(spacing: 8) {
            HStack(alignment: .firstTextBaseline, spacing: 2) {
                Text(String(format: "%.0f", speed))
                    .font(.system(size: radius * 0.6, weight: .bold))
                    .foregroundStyle(speedColor) // Dynamic color
                Text("km/h")
                    .font(.system(size: radius * 0.18, weight: .semibold))
                    .foregroundStyle(speedColor) // Consistent color
            }
            Text(headingString(from: heading))
                .font(.system(size: radius * 0.18, weight: .medium))
                .padding(.horizontal, 12).padding(.vertical, 8)
                .background(.black.opacity(0.3)) // Semi-transparent background
                .cornerRadius(12)
        }
        .shadow(color: .black.opacity(0.5), radius: 3, y: 2) // Text shadow
    }
}


private struct NeedleView: View, Equatable {
    let radius: CGFloat
    let speed: Double
    let maxSpeed: Double

    static func == (lhs: NeedleView, rhs: NeedleView) -> Bool {
        lhs.radius == rhs.radius && lhs.speed == rhs.speed && lhs.maxSpeed == rhs.maxSpeed
    }

    // Calculate needle angle, clamping speed to maxSpeed
    private var angle: Angle {
        let clampedSpeed = min(speed, maxSpeed) // Prevent needle going past max
        return .degrees(135) + .degrees(270 * (clampedSpeed / maxSpeed))
    }

    var body: some View {
        ZStack {
            // Main Pointer shape
            PointerShape()
                .frame(width: radius * 0.08, height: radius * 0.9)
                .offset(y: -radius * 0.45) // Position relative to center
                .foregroundStyle(.primary) // Use primary color for needle
                .overlay( // Add a subtle highlight
                    PointerShape()
                        .stroke(LinearGradient(colors: [.white.opacity(0.6), .clear], startPoint: .top, endPoint: .bottom), lineWidth: 1.5)
                )
                .rotationEffect(angle + .degrees(90)) // Rotate based on speed
                .shadow(color: .black.opacity(0.6), radius: 5, y: 5) // Needle shadow

            // Pivot circle at the base
            Circle()
                .fill(.secondary) // Use secondary color for pivot
                .frame(width: radius * 0.2, height: radius * 0.2)
                .shadow(radius: 3)
                .overlay( // Add a border to the pivot
                    Circle().stroke(Color.gray.opacity(0.5), lineWidth: 1)
                )
        }
    }
}


// Custom Shape for the needle pointer
private struct PointerShape: Shape {
    func path(in rect: CGRect) -> Path {
        Path { path in
            path.move(to: CGPoint(x: rect.midX, y: rect.minY)) // Tip
            path.addLine(to: CGPoint(x: rect.maxX, y: rect.maxY)) // Bottom-right
            path.addLine(to: CGPoint(x: rect.minX, y: rect.maxY)) // Bottom-left
            path.closeSubpath()
        }
    }
}


// Button view for the map icon
private struct MapButton: View {
    let action: () -> Void

    var body: some View {
        VStack {
            Spacer() // Pushes button to bottom
            HStack {
                Spacer() // Pushes button to right
                Button(action: action) {
                    Image(systemName: "map.fill")
                        .font(.title2)
                        .padding()
                        .background(.ultraThinMaterial) // Frosted glass effect
                        .foregroundStyle(.primary)
                        .clipShape(Circle())
                        .shadow(radius: 3)
                }
                .padding() // Padding around the button itself
            }
        }
    }
}


// Reusable Shape for the main gauge arc
private struct GaugeArcShape: Shape {
    func path(in rect: CGRect) -> Path {
        var p = Path()
        let center = CGPoint(x: rect.midX, y: rect.midY)
        let radius = min(rect.width, rect.height) / 2

        // Define the arc from 135 degrees (bottom-left) to 45 degrees (bottom-right)
        p.addArc(center: center,
                 radius: radius,
                 startAngle: .degrees(135),
                 endAngle: .degrees(45),
                 clockwise: false)

        return p
    }
}


// MARK: - Preview

#Preview {
    GaugeView(speed: 25, heading: 270, onMapButtonTapped: { print("Map tapped") })
        .frame(width: 300, height: 300) // Size for preview
        .padding() // Padding around preview
        .background(Color.gray.opacity(0.2)) // Background for context
}

